# 力扣 热题100 · 第90题 最长有效括号
# 链接: https://leetcode.cn/problems/longest-valid-parentheses/
#
# ---------- 思路 ----------
# 题目在问什么：只含 '(' 和 ')' 的字符串，求最长合法括号子串的长度。
#
# 做法：栈这下标。栈底先放 -1 表示「最后一个无法匹配的 ) 的位置」。遇到 '(' 压当前下标；遇到 ')' 弹栈，若栈空说明这个 ')' 无法匹配，压当前下标当新的「分界」；否则当前合法长度为 i - stack[-1]，用其更新答案。
#
# ---------- 关键点 ----------
# · 栈里存的是什么：存的是「最后一个无法参与匹配的位置」的下标。遇到 '(' 压当前下标，表示这个左括号还没被匹配；遇到 ')' 弹栈，表示和栈顶的 '(' 匹配了（或和栈底的「断点」配对失败）。弹完后栈顶就是「当前这段合法括号串」再往左的断点，所以当前合法长度 = i - stack[-1]。
# · 弹栈后栈空为什么要压当前 i：弹栈后栈空说明这个 ')' 把「从上一个断点到现在」的 '(' 都消耗完了，还多了一个 ')’，所以这个 ')' 的位置是新的「断点」——后面的合法段不能跨过它。压入 i 后，后续的合法长度会从 i 之后算起。
# · 栈底初始 -1：这样第一段合法括号（例如 "()"）在弹栈后栈顶变成 -1，长度 = 1 - (-1) = 2。若栈底是 0 或空，第一段合法时会算错或要特判。

class Solution:
    def longestValidParentheses(self, s: str) -> int:
        st = [-1]
        ans = 0
        for i, c in enumerate(s):
            if c == "(":
                st.append(i)
            else:
                st.pop()
                if not st:
                    st.append(i)
                else:
                    ans = max(ans, i - st[-1])
        return ans
