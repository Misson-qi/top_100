# 力扣 热题100 · 第3题 最长连续序列
# 链接: https://leetcode.cn/problems/longest-consecutive-sequence/
#
# ---------- 思路 ----------
# 题目在问什么：在未排序的数组里，找「连续整数」能组成的最长一段有多长。例如 [100,4,200,1,3,2] 里有 1,2,3,4 连续，长度 4。
#
# 暴力做法：枚举每个数当起点，往后看 +1、+2、+3… 能走多远。但这样同一个连续段会被重复枚举很多次（从 1 数一遍、从 2 又数一遍…），会变成 O(n^2)。
#
# 更好做法：先把所有数放进集合（方便 O(1) 查「某个数在不在」）。
# 只从「某段连续序列的最小值」开始数：也就是当 num - 1 不在集合里时，说明 num 是一段的开头，从它开始往后数 +1、+2… 看能数多长。
# 这样每一段连续序列只会被数一次，总复杂度 O(n)。
#
# ---------- 关键点 ----------
# · 为什么只从「num-1 不在集合里」的 num 开始数？一段连续数 [a, a+1, ..., b] 的最小值是 a。如果从 a 开始数，会数出整段长度；如果从 a+1、a+2… 开始数，得到的还是同一段，但会重复算很多次。所以只把「没有前一个数在集合里」的 num 当作段头，从它开始往后数，这样每一段连续序列只会被扩展一次，总时间 O(n)。
# · 要用 set 存数：后面要反复查 x+1、x+2… 在不在数组里，set 查是 O(1)，list 查是 O(n)。查的次数很多，用 list 会变成 O(n²)。
# · 遍历 set 而不是原数组：这样重复的数只会当一次「段头」候选；而且 while 里查的也是同一个 set，逻辑一致。

from typing import List


class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        s = set(nums)
        ans = 0
        for x in s:
            if x - 1 not in s:
                cur = 0
                while x + cur in s:
                    cur += 1
                ans = max(ans, cur)
        return ans
